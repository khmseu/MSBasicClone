<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MSBasic - Applesoft BASIC Interpreter: Variables Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MSBasic - Applesoft BASIC Interpreter<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A modern C++20 implementation of Applesoft II BASIC</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classVariables.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classVariables-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Variables Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Storage and management for program variables, arrays, and functions.  
 <a href="classVariables.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variables_8h_source.html">variables.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVariables_1_1FunctionInfo.html">FunctionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for user-defined function details.  <a href="structVariables_1_1FunctionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5610f6bf2bcfb696eb23961de493d563" id="r_a5610f6bf2bcfb696eb23961de493d563"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a5610f6bf2bcfb696eb23961de493d563">Variables</a> ()</td></tr>
<tr class="memdesc:a5610f6bf2bcfb696eb23961de493d563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classVariables.html" title="Storage and management for program variables, arrays, and functions.">Variables</a> storage system.  <br /></td></tr>
<tr class="separator:a5610f6bf2bcfb696eb23961de493d563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed267510268c0b0809ec89715f5fc10e" id="r_aed267510268c0b0809ec89715f5fc10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#aed267510268c0b0809ec89715f5fc10e">setVariable</a> (const std::string &amp;name, const <a class="el" href="classValue.html">Value</a> &amp;value)</td></tr>
<tr class="memdesc:aed267510268c0b0809ec89715f5fc10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a variable's value.  <br /></td></tr>
<tr class="separator:aed267510268c0b0809ec89715f5fc10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92f5e8f1968527cb417dff6d6163a13" id="r_ad92f5e8f1968527cb417dff6d6163a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#ad92f5e8f1968527cb417dff6d6163a13">unsetVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad92f5e8f1968527cb417dff6d6163a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a variable.  <br /></td></tr>
<tr class="separator:ad92f5e8f1968527cb417dff6d6163a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53064f12b5f8d026249651da34738773" id="r_a53064f12b5f8d026249651da34738773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValue.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a53064f12b5f8d026249651da34738773">getVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a53064f12b5f8d026249651da34738773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a variable's value.  <br /></td></tr>
<tr class="separator:a53064f12b5f8d026249651da34738773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdd76140761cd2a2676050d034f5bfd" id="r_a1bdd76140761cd2a2676050d034f5bfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a1bdd76140761cd2a2676050d034f5bfd">hasVariable</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1bdd76140761cd2a2676050d034f5bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable exists.  <br /></td></tr>
<tr class="separator:a1bdd76140761cd2a2676050d034f5bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c30050683017ad2e4089a0970eb2a8" id="r_a46c30050683017ad2e4089a0970eb2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a46c30050683017ad2e4089a0970eb2a8">clear</a> ()</td></tr>
<tr class="memdesc:a46c30050683017ad2e4089a0970eb2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all variables, arrays, and functions.  <br /></td></tr>
<tr class="separator:a46c30050683017ad2e4089a0970eb2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001cb5bcea1399eb054152be0b6b5c11" id="r_a001cb5bcea1399eb054152be0b6b5c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a001cb5bcea1399eb054152be0b6b5c11">dimArray</a> (const std::string &amp;name, const std::vector&lt; int &gt; &amp;dimensions)</td></tr>
<tr class="memdesc:a001cb5bcea1399eb054152be0b6b5c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension an array with specified sizes.  <br /></td></tr>
<tr class="separator:a001cb5bcea1399eb054152be0b6b5c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46000e478cd5c06dd44aa4d920fb717" id="r_ab46000e478cd5c06dd44aa4d920fb717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#ab46000e478cd5c06dd44aa4d920fb717">setArrayElement</a> (const std::string &amp;name, const std::vector&lt; int &gt; &amp;indices, const <a class="el" href="classValue.html">Value</a> &amp;value)</td></tr>
<tr class="memdesc:ab46000e478cd5c06dd44aa4d920fb717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an array element's value.  <br /></td></tr>
<tr class="separator:ab46000e478cd5c06dd44aa4d920fb717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4e16554d8b7ccdae688d2788ea174" id="r_acea4e16554d8b7ccdae688d2788ea174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValue.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#acea4e16554d8b7ccdae688d2788ea174">getArrayElement</a> (const std::string &amp;name, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:acea4e16554d8b7ccdae688d2788ea174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array element's value.  <br /></td></tr>
<tr class="separator:acea4e16554d8b7ccdae688d2788ea174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a931de8fc273ef6d14ef9b6c0bac4" id="r_ac18a931de8fc273ef6d14ef9b6c0bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#ac18a931de8fc273ef6d14ef9b6c0bac4">defineFunction</a> (const std::string &amp;name, const std::string &amp;param, const std::shared_ptr&lt; <a class="el" href="classExpression.html">Expression</a> &gt; &amp;expr)</td></tr>
<tr class="memdesc:ac18a931de8fc273ef6d14ef9b6c0bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a user function (DEF FN)  <br /></td></tr>
<tr class="separator:ac18a931de8fc273ef6d14ef9b6c0bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7836663fe15b2d70e6e19de9178496cd" id="r_a7836663fe15b2d70e6e19de9178496cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a7836663fe15b2d70e6e19de9178496cd">hasFunction</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a7836663fe15b2d70e6e19de9178496cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a function is defined.  <br /></td></tr>
<tr class="separator:a7836663fe15b2d70e6e19de9178496cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4867632eff5dc7cdaaccc4d666682ae4" id="r_a4867632eff5dc7cdaaccc4d666682ae4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVariables_1_1FunctionInfo.html">FunctionInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a4867632eff5dc7cdaaccc4d666682ae4">getFunction</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4867632eff5dc7cdaaccc4d666682ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function definition.  <br /></td></tr>
<tr class="separator:a4867632eff5dc7cdaaccc4d666682ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7779501b1ea42878d4f07c6a6b5c1a92" id="r_a7779501b1ea42878d4f07c6a6b5c1a92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a7779501b1ea42878d4f07c6a6b5c1a92">hasArray</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a7779501b1ea42878d4f07c6a6b5c1a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an array exists.  <br /></td></tr>
<tr class="separator:a7779501b1ea42878d4f07c6a6b5c1a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83237360e13f530dc1e04c310a701fe1" id="r_a83237360e13f530dc1e04c310a701fe1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a83237360e13f530dc1e04c310a701fe1">getArrayDimensions</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a83237360e13f530dc1e04c310a701fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array dimensions.  <br /></td></tr>
<tr class="separator:a83237360e13f530dc1e04c310a701fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f8bfec01773e338ffee7b9faa9748" id="r_a863f8bfec01773e338ffee7b9faa9748"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::vector&lt; int &gt;, <a class="el" href="classValue.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a863f8bfec01773e338ffee7b9faa9748">getArrayData</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a863f8bfec01773e338ffee7b9faa9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array data (for persistence)  <br /></td></tr>
<tr class="separator:a863f8bfec01773e338ffee7b9faa9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543be0e821ce15aeb32e44e1962bb6e8" id="r_a543be0e821ce15aeb32e44e1962bb6e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a543be0e821ce15aeb32e44e1962bb6e8">setArrayData</a> (const std::string &amp;name, const std::vector&lt; int &gt; &amp;dimensions, const std::map&lt; std::vector&lt; int &gt;, <a class="el" href="classValue.html">Value</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a543be0e821ce15aeb32e44e1962bb6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set array data (for restoration)  <br /></td></tr>
<tr class="separator:a543be0e821ce15aeb32e44e1962bb6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d875aabe12918fd50e5f2542375f20" id="r_a41d875aabe12918fd50e5f2542375f20"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#a41d875aabe12918fd50e5f2542375f20">getAllNumericVariables</a> () const</td></tr>
<tr class="memdesc:a41d875aabe12918fd50e5f2542375f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all numeric variables.  <br /></td></tr>
<tr class="separator:a41d875aabe12918fd50e5f2542375f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea55fad6fb5398f808b8de08c986f2e7" id="r_aea55fad6fb5398f808b8de08c986f2e7"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariables.html#aea55fad6fb5398f808b8de08c986f2e7">getAllStringVariables</a> () const</td></tr>
<tr class="memdesc:aea55fad6fb5398f808b8de08c986f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all string variables.  <br /></td></tr>
<tr class="separator:aea55fad6fb5398f808b8de08c986f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Storage and management for program variables, arrays, and functions. </p>
<p>The <a class="el" href="classVariables.html" title="Storage and management for program variables, arrays, and functions.">Variables</a> class implements the variable storage system for MSBasic, following Applesoft BASIC conventions for variable names and types.</p>
<p>Variable naming rules:</p><ul>
<li>Only first 2 characters are significant (case-insensitive)</li>
<li>Exception: FN names preserve FN prefix + 2 chars (e.g., FNxy)</li>
<li>'$' suffix denotes string variables</li>
<li>'' suffix denotes integer variables (16-bit clamped)</li>
</ul>
<p>Arrays:</p><ul>
<li>Multi-dimensional with arbitrary dimension count</li>
<li>Auto-dimension to size 10 per dimension if undeclared</li>
<li>Sparse storage using std::map for memory efficiency</li>
<li>Bounds checking with "BAD SUBSCRIPT" error</li>
</ul>
<p>User-defined functions:</p><ul>
<li>Stored with parameter name and expression AST</li>
<li>Evaluated by substituting parameter value</li>
<li>Follow FN naming conventions </li>
</ul>

<p class="definition">Definition at line <a class="el" href="variables_8h_source.html#l00051">51</a> of file <a class="el" href="variables_8h_source.html">variables.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5610f6bf2bcfb696eb23961de493d563" name="a5610f6bf2bcfb696eb23961de493d563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5610f6bf2bcfb696eb23961de493d563">&#9670;&#160;</a></span>Variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Variables::Variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classVariables.html" title="Storage and management for program variables, arrays, and functions.">Variables</a> storage system. </p>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00032">32</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a46c30050683017ad2e4089a0970eb2a8" name="a46c30050683017ad2e4089a0970eb2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c30050683017ad2e4089a0970eb2a8">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all variables, arrays, and functions. </p>
<p>Clear all variables and arrays.</p>
<p>Resets the <a class="el" href="classVariables.html" title="Storage and management for program variables, arrays, and functions.">Variables</a> object to initial state. Called by CLR command.</p>
<p>Removes all variables and arrays from memory. User-defined functions (DEF FN) are preserved, matching Applesoft BASIC behavior where functions persist across CLEAR commands.</p>
<p>This is called by the CLR and NEW commands. </p>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00186">186</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l00210">Interpreter::clearState()</a>, and <a class="el" href="interpreter_8cpp_source.html#l00194">Interpreter::newProgram()</a>.</p>

</div>
</div>
<a id="ac18a931de8fc273ef6d14ef9b6c0bac4" name="ac18a931de8fc273ef6d14ef9b6c0bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18a931de8fc273ef6d14ef9b6c0bac4">&#9670;&#160;</a></span>defineFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::defineFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classExpression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a user function (DEF FN) </p>
<p>Define a user function (DEF FN implementation)</p>
<p>Stores a user-defined function with its parameter and body expression. Function calls will substitute the parameter value and evaluate the body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name (e.g., "FNxy") </td></tr>
    <tr><td class="paramname">param</td><td>Parameter name (e.g., "x") </td></tr>
    <tr><td class="paramname">expr</td><td><a class="el" href="classExpression.html" title="Base class for all expression AST nodes.">Expression</a> AST for the function body</td></tr>
  </table>
  </dd>
</dl>
<p>Stores a user-defined function definition for later evaluation. Functions defined with DEF FN can be called like built-in functions.</p>
<p>Function definition:</p><ul>
<li>Function name must start with "FN" (e.g., FNxy, FNa, FNmax)</li>
<li>Single parameter (Applesoft limitation)</li>
<li><a class="el" href="classExpression.html" title="Base class for all expression AST nodes.">Expression</a> can reference parameter and global variables</li>
</ul>
<p>Function naming:</p><ul>
<li>Name normalized to FN + 2 chars (FNxy, not FNxyz)</li>
<li>Case insensitive: FNA, FNa, Fna are the same</li>
<li>Normalized before storage for consistent lookup</li>
</ul>
<p>Function storage:</p><ul>
<li>Functions stored separately from variables</li>
<li>Functions persist across CLR (variables cleared, functions kept)</li>
<li>NEW command clears functions along with everything else</li>
<li>Redefining a function replaces the previous definition</li>
</ul>
<p>Function evaluation:</p><ul>
<li>Function call FNxy(10) substitutes parameter with value 10</li>
<li><a class="el" href="classExpression.html" title="Base class for all expression AST nodes.">Expression</a> evaluated in context with parameter substituted</li>
<li>Can reference and modify global variables</li>
<li>Recursive calls supported but uncommon</li>
</ul>
<p>Examples: DEF FNA(X) = X * X DEF FNB(Y) = SQR(Y * Y + 1) DEF FNC(Z) = INT(Z + 0.5)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name (e.g., "FNXY") - normalized internally </td></tr>
    <tr><td class="paramname">param</td><td>Parameter variable name (e.g., "X") </td></tr>
    <tr><td class="paramname">expr</td><td>Function body expression AST </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00394">394</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">References <a class="el" href="variables_8h_source.html#l00176">Variables::FunctionInfo::body</a>, and <a class="el" href="variables_8h_source.html#l00174">Variables::FunctionInfo::parameter</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l01024">DefStmt::execute()</a>.</p>

</div>
</div>
<a id="a001cb5bcea1399eb054152be0b6b5c11" name="a001cb5bcea1399eb054152be0b6b5c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001cb5bcea1399eb054152be0b6b5c11">&#9670;&#160;</a></span>dimArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::dimArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimension an array with specified sizes. </p>
<p>Creates a new array with the given dimensions. Arrays are stored sparsely - elements are created on demand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name (normalized) </td></tr>
    <tr><td class="paramname">dimensions</td><td>Vector of dimension sizes (each must be &gt; 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if array already dimensioned (REDIM error)</td></tr>
  </table>
  </dd>
</dl>
<p>Explicitly dimensions an array to specified sizes per dimension. This is called by the DIM statement or automatically on first array use.</p>
<p>Array index behavior:</p><ul>
<li>Indices start at 0 and go to dimension size (inclusive)</li>
<li>DIM A(10) creates indices 0-10 (11 elements)</li>
<li>Multi-dimensional: DIM A(5,5) creates 6×6 grid (indices 0-5)</li>
</ul>
<p>Auto-dimensioning:</p><ul>
<li>If array accessed before DIM, auto-dimensioned to size 10 per dimension</li>
<li>Auto-dimensioning matches Applesoft BASIC behavior</li>
<li>Explicit DIM overrides auto-dimension (if array not yet used)</li>
</ul>
<p>Memory management:</p><ul>
<li>Uses sparse storage (only stores non-default values)</li>
<li>Clearing array data frees all element storage</li>
<li>Redimensioning clears existing array data</li>
</ul>
<p>Error conditions:</p><ul>
<li>Cannot redimension an array that's already in use (REDIM'D ARRAY ERROR)</li>
<li>Handled by caller (<a class="el" href="classDimStmt.html">DimStmt</a>) to check if array exists</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name (normalized internally) </td></tr>
    <tr><td class="paramname">dimensions</td><td>Vector of dimension sizes (e.g., [10] for 1D, [5,5] for 2D) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00220">220</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00833">DimStmt::execute()</a>, <a class="el" href="variables_8cpp_source.html#l00326">getArrayElement()</a>, and <a class="el" href="variables_8cpp_source.html#l00261">setArrayElement()</a>.</p>

</div>
</div>
<a id="a41d875aabe12918fd50e5f2542375f20" name="a41d875aabe12918fd50e5f2542375f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d875aabe12918fd50e5f2542375f20">&#9670;&#160;</a></span>getAllNumericVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, double &gt; Variables::getAllNumericVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all numeric variables. </p>
<p>Returns a map of all numeric (non-string, non-integer) variables for saving to disk via ProDOS STORE command.</p>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;std::string, double&gt; Map of variable names to values</dd></dl>
<p>Returns a map of all numeric variables (non-string) for iteration or inspection. Used for debugging and state export.</p>
<dl class="section return"><dt>Returns</dt><dd>Map of normalized variable names to numeric values </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00516">516</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02430">Interpreter::storeVariables()</a>.</p>

</div>
</div>
<a id="aea55fad6fb5398f808b8de08c986f2e7" name="aea55fad6fb5398f808b8de08c986f2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea55fad6fb5398f808b8de08c986f2e7">&#9670;&#160;</a></span>getAllStringVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; Variables::getAllStringVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all string variables. </p>
<p>Returns a map of all string variables (names ending in $) for saving to disk via ProDOS STORE command.</p>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;std::string, std::string&gt; Map of variable names to values</dd></dl>
<p>Returns a map of all string variables for iteration or inspection. Used for debugging and state export.</p>
<dl class="section return"><dt>Returns</dt><dd>Map of normalized variable names to string values </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00534">534</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02430">Interpreter::storeVariables()</a>.</p>

</div>
</div>
<a id="a863f8bfec01773e338ffee7b9faa9748" name="a863f8bfec01773e338ffee7b9faa9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863f8bfec01773e338ffee7b9faa9748">&#9670;&#160;</a></span>getArrayData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::vector&lt; int &gt;, <a class="el" href="classValue.html">Value</a> &gt; &amp; Variables::getArrayData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get array data (for persistence) </p>
<p>Get array data storage.</p>
<p>Returns the sparse map of array elements for saving to disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::map&lt;std::vector&lt;int&gt;, <a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a>&gt;&amp; Array element map </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if array doesn't exist</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the sparse array data map. Array elements are stored as map entries keyed by dimension indices. Uninitialized elements are not stored (sparse storage).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of dimension indices to values </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if array not defined </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00480">480</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02013">Interpreter::storeArray()</a>.</p>

</div>
</div>
<a id="a83237360e13f530dc1e04c310a701fe1" name="a83237360e13f530dc1e04c310a701fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83237360e13f530dc1e04c310a701fe1">&#9670;&#160;</a></span>getArrayDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; Variables::getArrayDimensions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get array dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;int&gt;&amp; Vector of dimension sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if array doesn't exist</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the dimension sizes for a dimensioned array.</p>
<p>Example: DIM A(5,10) creates array with dimensions [5, 10]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if array not defined </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00459">459</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02013">Interpreter::storeArray()</a>.</p>

</div>
</div>
<a id="acea4e16554d8b7ccdae688d2788ea174" name="acea4e16554d8b7ccdae688d2788ea174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4e16554d8b7ccdae688d2788ea174">&#9670;&#160;</a></span>getArrayElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValue.html">Value</a> Variables::getArrayElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an array element's value. </p>
<p>Get an array element value.</p>
<p>Auto-dimensions the array to size 10 per dimension if not yet declared. Returns <a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a>(0.0) for uninitialized numeric elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">indices</td><td>Subscript values for each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a> The element's value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>on bad subscript (out of bounds)</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of a specific array element identified by indices. Automatically dimensions the array if not yet dimensioned (size 10 per dimension). Performs bounds checking and returns default values for uninitialized elements.</p>
<p>Auto-dimensioning:</p><ul>
<li>If array not explicitly DIM'd, auto-dimensions to size 10</li>
<li>Matches Applesoft BASIC behavior for undeclared arrays</li>
<li>Multi-dimensional arrays auto-dimension each axis to 10</li>
</ul>
<p>Default values:</p><ul>
<li>Uninitialized numeric array elements return 0.0</li>
<li>Uninitialized string array elements return ""</li>
<li>Sparse storage: only explicitly set elements consume memory</li>
</ul>
<p>Bounds checking:</p><ul>
<li>Each index must be &gt;= 0 and &lt;= dimension size</li>
<li>Accessing A(11) when DIM A(10) raises "BAD SUBSCRIPT ERROR"</li>
<li>All dimensions checked before access</li>
</ul>
<p>Type handling:</p><ul>
<li>Numeric arrays return numeric values</li>
<li>String arrays (name ending with $) return string values</li>
<li>Integer arrays (name ending with %) return clamped integers</li>
</ul>
<p>Examples: X = A(5) (1D array access) Y = B(2,3) (2D array access) S$ = C$(I) (string array) N% = D%(10) (integer array)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of indices (one per dimension) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array element value, or default (0 or "") if uninitialized </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any index out of bounds ("BAD SUBSCRIPT ERROR") </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00326">326</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">References <a class="el" href="variables_8cpp_source.html#l00220">dimArray()</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00418">ArrayAccessExpr::evaluate()</a>.</p>

</div>
</div>
<a id="a4867632eff5dc7cdaaccc4d666682ae4" name="a4867632eff5dc7cdaaccc4d666682ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4867632eff5dc7cdaaccc4d666682ae4">&#9670;&#160;</a></span>getFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVariables_1_1FunctionInfo.html">Variables::FunctionInfo</a> &amp; Variables::getFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function definition. </p>
<p>Get user-defined function definition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="structVariables_1_1FunctionInfo.html" title="Storage for user-defined function details.">FunctionInfo</a>&amp; Function details </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if function not defined</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the function definition for evaluation. Function calls substitute the parameter value and evaluate the function body expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name (e.g., "FNXY") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function information (parameter name and body expression) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if function is not defined </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00425">425</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00528">UserFunctionCallExpr::evaluate()</a>.</p>

</div>
</div>
<a id="a53064f12b5f8d026249651da34738773" name="a53064f12b5f8d026249651da34738773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53064f12b5f8d026249651da34738773">&#9670;&#160;</a></span>getVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValue.html">Value</a> Variables::getVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a variable's value. </p>
<p>Get a variable value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a> The variable's current value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if variable doesn't exist</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of a variable. Returns default values for uninitialized variables following Applesoft BASIC conventions:</p><ul>
<li>String variables ($): empty string ""</li>
<li>Numeric variables: 0.0</li>
</ul>
<p>Examples: getVariable("X") → returns 0.0 if X not set getVariable("NAME$") → returns "" if NAME$ not set getVariable("COUNT%") → returns 0 if COUNT% not set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable value, or default if uninitialized </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00150">150</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00404">VariableExpr::evaluate()</a>, and <a class="el" href="interpreter_8cpp_source.html#l03142">Interpreter::nextForLoop()</a>.</p>

</div>
</div>
<a id="a7779501b1ea42878d4f07c6a6b5c1a92" name="a7779501b1ea42878d4f07c6a6b5c1a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7779501b1ea42878d4f07c6a6b5c1a92">&#9670;&#160;</a></span>hasArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Variables::hasArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an array exists. </p>
<p>Check if an array has been dimensioned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if array is dimensioned, false otherwise</dd></dl>
<p>Tests whether an array has been explicitly dimensioned with DIM or auto-dimensioned by first use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if array exists, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00443">443</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02013">Interpreter::storeArray()</a>.</p>

</div>
</div>
<a id="a7836663fe15b2d70e6e19de9178496cd" name="a7836663fe15b2d70e6e19de9178496cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7836663fe15b2d70e6e19de9178496cd">&#9670;&#160;</a></span>hasFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Variables::hasFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a function is defined. </p>
<p>Check if a user-defined function exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function is defined, false otherwise</dd></dl>
<p>Tests whether a function has been defined with DEF FN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Function name (e.g., "FNXY") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function is defined, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00411">411</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

</div>
</div>
<a id="a1bdd76140761cd2a2676050d034f5bfd" name="a1bdd76140761cd2a2676050d034f5bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdd76140761cd2a2676050d034f5bfd">&#9670;&#160;</a></span>hasVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Variables::hasVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a variable exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if variable is defined, false otherwise</dd></dl>
<p>Tests whether a variable has been explicitly set. Returns false for variables that would return default values (0 or "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if variable has been set, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00173">173</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

</div>
</div>
<a id="a543be0e821ce15aeb32e44e1962bb6e8" name="a543be0e821ce15aeb32e44e1962bb6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543be0e821ce15aeb32e44e1962bb6e8">&#9670;&#160;</a></span>setArrayData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::setArrayData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::vector&lt; int &gt;, <a class="el" href="classValue.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set array data (for restoration) </p>
<p>Set array data (bulk restore)</p>
<p>Replaces array contents with loaded data. Used by RECALL command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">dimensions</td><td>Dimension sizes </td></tr>
    <tr><td class="paramname">data</td><td>Map of element values</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the complete array dimensions and data. Used by RECALL command to restore arrays from tape storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">dimensions</td><td>Array dimension sizes </td></tr>
    <tr><td class="paramname">data</td><td>Complete array data map </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00499">499</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="interpreter_8cpp_source.html#l02180">Interpreter::recallArray()</a>.</p>

</div>
</div>
<a id="ab46000e478cd5c06dd44aa4d920fb717" name="ab46000e478cd5c06dd44aa4d920fb717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46000e478cd5c06dd44aa4d920fb717">&#9670;&#160;</a></span>setArrayElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::setArrayElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classValue.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an array element's value. </p>
<p>Set an array element value.</p>
<p>Auto-dimensions the array to size 10 per dimension if not yet declared. Creates the element if it doesn't exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">indices</td><td>Subscript values for each dimension </td></tr>
    <tr><td class="paramname">value</td><td>The value to store </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>on bad subscript (out of bounds)</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the value of a specific array element identified by indices. Automatically dimensions the array if not yet dimensioned (size 10 per dimension). Performs bounds checking and raises error if indices out of range.</p>
<p>Auto-dimensioning:</p><ul>
<li>If array not explicitly DIM'd, auto-dimensions to size 10</li>
<li>Example: A(5) = 10 auto-creates A with indices 0-10</li>
<li>Multi-dimensional arrays auto-dimension each axis to 10</li>
</ul>
<p>Integer coercion:</p><ul>
<li>Array names ending with % store integer values</li>
<li>Values are clamped to 16-bit signed range (-32768 to 32767)</li>
<li>Matches Applesoft BASIC integer variable behavior</li>
</ul>
<p>Sparse storage:</p><ul>
<li>Only explicitly set elements are stored in memory</li>
<li>Unset elements return default values (0 or "")</li>
<li>Efficient for large arrays with few used elements</li>
</ul>
<p>Examples: A(5) = 100 (1D array access) B(2,3) = 50 (2D array access) C$(I) = "HELLO" (string array) D%(10) = 32000 (integer array)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Array name </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of indices (one per dimension) </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a> to store </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any index out of bounds ("BAD SUBSCRIPT ERROR") </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00261">261</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">References <a class="el" href="variables_8cpp_source.html#l00220">dimArray()</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00687">ArrayLetStmt::execute()</a>, and <a class="el" href="parser_8cpp_source.html#l00878">ReadStmt::execute()</a>.</p>

</div>
</div>
<a id="aed267510268c0b0809ec89715f5fc10e" name="aed267510268c0b0809ec89715f5fc10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed267510268c0b0809ec89715f5fc10e">&#9670;&#160;</a></span>setVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::setVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classValue.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a variable's value. </p>
<p>Set a variable value.</p>
<p>Creates the variable if it doesn't exist, or updates its value. Variable name is normalized according to Applesoft conventions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name (may include $, %, or FN prefix) </td></tr>
    <tr><td class="paramname">value</td><td>The value to store </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>on type mismatch (e.g., string to numeric)</td></tr>
  </table>
  </dd>
</dl>
<p>Stores a value in a variable, applying type coercion for integer variables. Variable names are normalized according to Applesoft rules (2-char significance).</p>
<p>Type handling:</p><ul>
<li>Integer variables (name ends with %): value is clamped to 16-bit signed range</li>
<li>String variables (name ends with $): value stored as-is</li>
<li>Numeric variables: value stored as-is (<a class="el" href="classFloat40.html" title="Applesoft-compatible 40-bit floating point number.">Float40</a> precision)</li>
</ul>
<p>Examples: setVariable("COUNTER%", 100) → stores 100 as integer setVariable("NAME$", "HELLO") → stores "HELLO" as string setVariable("X", 3.14159) → stores 3.14159 as number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name (may include $ or % suffix) </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="classValue.html" title="Runtime value that can hold either a number or a string.">Value</a> to store (type coercion applied for %) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00114">114</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parser_8cpp_source.html#l00670">LetStmt::execute()</a>, <a class="el" href="parser_8cpp_source.html#l00763">ForStmt::execute()</a>, <a class="el" href="parser_8cpp_source.html#l00793">InputStmt::execute()</a>, <a class="el" href="parser_8cpp_source.html#l00878">ReadStmt::execute()</a>, <a class="el" href="parser_8cpp_source.html#l00984">GetStmt::execute()</a>, <a class="el" href="interpreter_8cpp_source.html#l03142">Interpreter::nextForLoop()</a>, and <a class="el" href="interpreter_8cpp_source.html#l02497">Interpreter::restoreVariables()</a>.</p>

</div>
</div>
<a id="ad92f5e8f1968527cb417dff6d6163a13" name="ad92f5e8f1968527cb417dff6d6163a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92f5e8f1968527cb417dff6d6163a13">&#9670;&#160;</a></span>unsetVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Variables::unsetVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a variable. </p>
<p>Remove a variable from storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Deletes a variable from memory. If the variable doesn't exist, this operation silently succeeds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="variables_8cpp_source.html#l00130">130</a> of file <a class="el" href="variables_8cpp_source.html">variables.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="variables_8h_source.html">variables.h</a></li>
<li>src/<a class="el" href="variables_8cpp_source.html">variables.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classVariables.html">Variables</a></li>
    <li class="footer">Generated on Tue Dec 23 2025 21:52:02 for MSBasic - Applesoft BASIC Interpreter by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
